name: Update web flasher manifests

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (optional, defaults to latest)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  build-pages:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve release for manual dispatch
        if: ${{ github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ inputs.tag }}
        run: |
          python - <<'PY'
          import json, os, urllib.request

          token = os.environ.get("GH_TOKEN")
          repo  = os.environ.get("REPO")
          tag   = os.environ.get("TAG") or ""

          if not token or not repo:
            raise SystemExit("Missing GH_TOKEN or REPO")

          url = f"https://api.github.com/repos/{repo}/releases/tags/{tag}" if tag else f"https://api.github.com/repos/{repo}/releases/latest"

          req = urllib.request.Request(url, headers={
            "Authorization": f"Bearer {token}",
            "Accept": "application/vnd.github+json"
          })

          with urllib.request.urlopen(req, timeout=30) as resp:
            release = json.loads(resp.read().decode("utf-8"))

          event = {"release": release}
          out_path = "/tmp/release-event.json"
          with open(out_path, "w", encoding="utf-8") as f:
            json.dump(event, f)

          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write(f"EVENT_PATH={out_path}\n")

          print(f"Wrote {out_path}")
          PY

      - name: Generate firmware manifests + download BINs to docs/firmware
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python - <<'PY'
          import json
          import os
          import re
          import pathlib
          import subprocess

          event_path = os.environ.get("EVENT_PATH") or os.environ.get("GITHUB_EVENT_PATH")
          with open(event_path, "r", encoding="utf-8") as f:
            event = json.load(f)

          release = event.get("release") or {}
          tag = release.get("tag_name") or ""
          assets = release.get("assets") or []

          bins = []
          for asset in assets:
            name = asset.get("name", "")
            if not name.endswith(".bin") or name.endswith(".bin.ota"):
              continue
            bins.append(asset)

          if not bins:
            raise SystemExit("No .bin assets in release")

          def classify(name):
            lower = name.lower()
            if "c3" in lower or "esp32c3" in lower:
              return "c3", "ESP32-C3", "ESP32-C3", "ESP32-C3 Nano und aehnliche Boards."
            if "d1_mini" in lower or "d1mini" in lower or "wemos_d1_mini" in lower:
              return "d1mini", "ESP32", "ESP32 D1 Mini", "Wemos D1 Mini und kompatible ESP32 Boards."
            if "esp32" in lower:
              return "esp32", "ESP32", "ESP32", "Allgemeines ESP32 Board."
            return None

          def find_version(name):
            m = re.search(r"[._-]v?(\d+\.\d+\.\d+[^._-]*)", name, re.IGNORECASE)
            if m:
              return m.group(1)
            m = re.search(r"v?(\d+\.\d+\.\d+[^._-]*)", tag, re.IGNORECASE)
            if m:
              return m.group(1)
            return ""

          def score(name):
            lower = name.lower()
            value = 0
            if "release" in lower or "rel" in lower:
              value += 1
            if "dbg" in lower or "debug" in lower:
              value -= 1
            return value

          docs = pathlib.Path("docs")
          fwdir = docs / "firmware"
          docs.mkdir(exist_ok=True)
          fwdir.mkdir(exist_ok=True)

          picked = {}
          for asset in bins:
            name = asset.get("name", "")
            info = classify(name)
            if not info:
              continue
            vid, chip, title, desc = info
            cur = picked.get(vid)
            if cur is None or score(name) > score(cur.get("name", "")):
              picked[vid] = {
                "id": vid,
                "chip": chip,
                "title": title,
                "desc": desc,
                "name": name,
                "version": find_version(name),
                "url": asset.get("browser_download_url")
              }

          if not picked:
            raise SystemExit("No recognized ESP32 variants in release assets.")

          # Download selected BINs into docs/firmware (same-origin for Pages -> no CORS issues)
          for vid in picked:
            item = picked[vid]
            out_path = fwdir / item["name"]
            url = item["url"]

            # Use curl with -L to follow redirects (GitHub release -> CDN)
            cmd = ["curl", "-L", "-f", "-sS", "-o", str(out_path), url]
            print("Downloading:", url, "->", out_path)
            subprocess.check_call(cmd)

          variants = []
          for vid in sorted(picked.keys()):
            item = picked[vid]
            manifest_name = f"manifest-bambu-{vid}.json"
            local_bin_path = f"./firmware/{item['name']}"

            manifest = {
              "name": "BambuBeacon",
              "new_install_prompt_erase": True,
              "builds": [
                {
                  "chipFamily": item["chip"],
                  "parts": [
                    {
                      "path": local_bin_path,
                      "offset": 0
                    }
                  ]
                }
              ]
            }
            (docs / manifest_name).write_text(json.dumps(manifest, indent=2), encoding="utf-8")

            variants.append({
              "id": item["id"],
              "name": item["title"],
              "chipFamily": item["chip"],
              "description": item["desc"],
              "version": item["version"] or "unbekannt",
              "manifest": f"./{manifest_name}",
              "binary": local_bin_path,
              "available": True
            })

          (docs / "variants.json").write_text(json.dumps({"variants": variants}, indent=2), encoding="utf-8")
          print(f"Wrote {len(variants)} variants and downloaded {len(picked)} BINs.")
          PY

      - name: Commit docs updates
        run: |
          if git diff --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/variants.json docs/manifest-bambu-*.json docs/firmware/*.bin
          git commit -m "Update web flasher manifests + firmware"
          git push
